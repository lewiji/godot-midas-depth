[gd_resource type="Shader" format=2]

[resource]
code = "shader_type spatial;

render_mode diffuse_burley, blend_mix, depth_draw_opaque, ambient_light_disabled, cull_disabled;

uniform sampler2D albedo_texture : hint_albedo;
uniform sampler2D depth_texture : hint_white;
uniform float depth_scale = 2.0;
uniform float depth_min = -10.0;
uniform float depth_max = 10.0;
uniform bool calculate_normals = false;

varying flat mat4 model_view_matrix;
varying vec3 last_normal;

void vertex() {
	float depth = texture(depth_texture, clamp(UV, 0.0, 1.0)).r;
	VERTEX.y += depth * clamp(depth_scale, depth_min, depth_max);
    model_view_matrix = CAMERA_MATRIX*MODELVIEW_MATRIX;
}

vec3 getPos(float depth, mat4 mvm, mat4 ipm, vec2 suv, mat4 wm, mat4 icm, float texelSize){
  vec4 pos = inverse(mvm) * ipm * vec4((suv * texelSize - texelSize / 2.0), depth * texelSize - texelSize / 2.0, texelSize / 2.0);
  pos.xyz /= (pos.w+0.0001*(1.-abs(sign(pos.w))));
  return (pos*icm).xyz+wm[3].xyz;
}

// using improved version from https://www.shadertoy.com/view/fsVczR
vec3 computeNormalImproved( sampler2D depth_tx, mat4 mvm, mat4 ipm, vec2 suv, mat4 wm, mat4 icm, vec2 iResolution, float texelSize)
{
    vec2 e = vec2(texelSize/iResolution);
    float c0 = texture(depth_tx,suv           ).r;
    float l2 = texture(depth_tx,suv-vec2(texelSize,0)*e).r;
    float l1 = texture(depth_tx,suv-vec2(texelSize / 2.0,0)*e).r;
    float r1 = texture(depth_tx,suv+vec2(texelSize / 2.0,0)*e).r;
    float r2 = texture(depth_tx,suv+vec2(texelSize,0)*e).r;
    float b2 = texture(depth_tx,suv-vec2(0,texelSize)*e).r;
    float b1 = texture(depth_tx,suv-vec2(0,texelSize / 2.0)*e).r;
    float t1 = texture(depth_tx,suv+vec2(0,texelSize / 2.0)*e).r;
    float t2 = texture(depth_tx,suv+vec2(0,texelSize)*e).r;

    float dl = abs(l1*l2/(texelSize * 2.0 *l2-l1)-c0);
    float dr = abs(r1*r2/(texelSize * 2.0*r2-r1)-c0);
    float db = abs(b1*b2/(texelSize * 2.0*b2-b1)-c0);
    float dt = abs(t1*t2/(texelSize * 2.0*t2-t1)-c0);

    vec3 ce = getPos(c0, mvm, ipm, suv, wm, icm, texelSize);

    vec3 dpdx = (dl<dr) ?  ce-getPos(l1, mvm, ipm, suv-vec2(texelSize,0)*e, wm, icm, texelSize) : 
                          -ce+getPos(r1, mvm, ipm, suv+vec2(texelSize,0)*e, wm, icm, texelSize) ;
    vec3 dpdy = (db<dt) ?  ce-getPos(b1, mvm, ipm, suv-vec2(0,texelSize)*e, wm, icm, texelSize) : 
                          -ce+getPos(t1, mvm, ipm, suv+vec2(0,texelSize)*e, wm, icm, texelSize) ;

    return mix(normalize(cross(dpdx,dpdy)), last_normal, 0.1);
}

void fragment() {
	int lod = int(clamp(round(abs(WORLD_MATRIX[3].xyz - CAMERA_MATRIX[3].xyz).z / depth_max / 2.0), 0.0, 3.0));
	vec2 texture_size = vec2(textureSize(albedo_texture, lod));
	vec2 xy = UV * texture_size;
	vec4 albedo = texelFetch(albedo_texture, ivec2(xy), int(lod));
	ALBEDO = albedo.rgb;
	
	if (calculate_normals) {
		vec2 texture_size_no_lod = vec2(textureSize(albedo_texture, 0));
		vec3 norm = computeNormalImproved(depth_texture, model_view_matrix, INV_PROJECTION_MATRIX, UV, WORLD_MATRIX, INV_CAMERA_MATRIX, texture_size, texture_size_no_lod.x / 256.0);
		NORMAL = vec3(-norm.x, -norm.y, 1.0-norm.z) * 0.5;
		last_normal = NORMAL;
	}
}
"
